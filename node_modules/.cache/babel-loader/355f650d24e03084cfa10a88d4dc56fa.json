{"ast":null,"code":"const JsonWebTokenError = require('./lib/JsonWebTokenError');\n\nconst NotBeforeError = require('./lib/NotBeforeError');\n\nconst TokenExpiredError = require('./lib/TokenExpiredError');\n\nconst decode = require('./decode');\n\nconst timespan = require('./lib/timespan');\n\nconst validateAsymmetricKey = require('./lib/validateAsymmetricKey');\n\nconst PS_SUPPORTED = require('./lib/psSupported');\n\nconst jws = require('jws');\n\nconst {\n  KeyObject,\n  createSecretKey,\n  createPublicKey\n} = require(\"crypto\");\n\nconst PUB_KEY_ALGS = ['RS256', 'RS384', 'RS512'];\nconst EC_KEY_ALGS = ['ES256', 'ES384', 'ES512'];\nconst RSA_KEY_ALGS = ['RS256', 'RS384', 'RS512'];\nconst HS_ALGS = ['HS256', 'HS384', 'HS512'];\n\nif (PS_SUPPORTED) {\n  PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, 'PS256', 'PS384', 'PS512');\n  RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, 'PS256', 'PS384', 'PS512');\n}\n\nmodule.exports = function (jwtString, secretOrPublicKey, options, callback) {\n  if (typeof options === 'function' && !callback) {\n    callback = options;\n    options = {};\n  }\n\n  if (!options) {\n    options = {};\n  } //clone this object since we are going to mutate it.\n\n\n  options = Object.assign({}, options);\n  let done;\n\n  if (callback) {\n    done = callback;\n  } else {\n    done = function (err, data) {\n      if (err) throw err;\n      return data;\n    };\n  }\n\n  if (options.clockTimestamp && typeof options.clockTimestamp !== 'number') {\n    return done(new JsonWebTokenError('clockTimestamp must be a number'));\n  }\n\n  if (options.nonce !== undefined && (typeof options.nonce !== 'string' || options.nonce.trim() === '')) {\n    return done(new JsonWebTokenError('nonce must be a non-empty string'));\n  }\n\n  if (options.allowInvalidAsymmetricKeyTypes !== undefined && typeof options.allowInvalidAsymmetricKeyTypes !== 'boolean') {\n    return done(new JsonWebTokenError('allowInvalidAsymmetricKeyTypes must be a boolean'));\n  }\n\n  const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);\n\n  if (!jwtString) {\n    return done(new JsonWebTokenError('jwt must be provided'));\n  }\n\n  if (typeof jwtString !== 'string') {\n    return done(new JsonWebTokenError('jwt must be a string'));\n  }\n\n  const parts = jwtString.split('.');\n\n  if (parts.length !== 3) {\n    return done(new JsonWebTokenError('jwt malformed'));\n  }\n\n  let decodedToken;\n\n  try {\n    decodedToken = decode(jwtString, {\n      complete: true\n    });\n  } catch (err) {\n    return done(err);\n  }\n\n  if (!decodedToken) {\n    return done(new JsonWebTokenError('invalid token'));\n  }\n\n  const header = decodedToken.header;\n  let getSecret;\n\n  if (typeof secretOrPublicKey === 'function') {\n    if (!callback) {\n      return done(new JsonWebTokenError('verify must be called asynchronous if secret or public key is provided as a callback'));\n    }\n\n    getSecret = secretOrPublicKey;\n  } else {\n    getSecret = function (header, secretCallback) {\n      return secretCallback(null, secretOrPublicKey);\n    };\n  }\n\n  return getSecret(header, function (err, secretOrPublicKey) {\n    if (err) {\n      return done(new JsonWebTokenError('error in secret or public key callback: ' + err.message));\n    }\n\n    const hasSignature = parts[2].trim() !== '';\n\n    if (!hasSignature && secretOrPublicKey) {\n      return done(new JsonWebTokenError('jwt signature is required'));\n    }\n\n    if (hasSignature && !secretOrPublicKey) {\n      return done(new JsonWebTokenError('secret or public key must be provided'));\n    }\n\n    if (!hasSignature && !options.algorithms) {\n      return done(new JsonWebTokenError('please specify \"none\" in \"algorithms\" to verify unsigned tokens'));\n    }\n\n    if (secretOrPublicKey != null && !(secretOrPublicKey instanceof KeyObject)) {\n      try {\n        secretOrPublicKey = createPublicKey(secretOrPublicKey);\n      } catch (_) {\n        try {\n          secretOrPublicKey = createSecretKey(typeof secretOrPublicKey === 'string' ? Buffer.from(secretOrPublicKey) : secretOrPublicKey);\n        } catch (_) {\n          return done(new JsonWebTokenError('secretOrPublicKey is not valid key material'));\n        }\n      }\n    }\n\n    if (!options.algorithms) {\n      if (secretOrPublicKey.type === 'secret') {\n        options.algorithms = HS_ALGS;\n      } else if (['rsa', 'rsa-pss'].includes(secretOrPublicKey.asymmetricKeyType)) {\n        options.algorithms = RSA_KEY_ALGS;\n      } else if (secretOrPublicKey.asymmetricKeyType === 'ec') {\n        options.algorithms = EC_KEY_ALGS;\n      } else {\n        options.algorithms = PUB_KEY_ALGS;\n      }\n    }\n\n    if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {\n      return done(new JsonWebTokenError('invalid algorithm'));\n    }\n\n    if (header.alg.startsWith('HS') && secretOrPublicKey.type !== 'secret') {\n      return done(new JsonWebTokenError(`secretOrPublicKey must be a symmetric key when using ${header.alg}`));\n    } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey.type !== 'public') {\n      return done(new JsonWebTokenError(`secretOrPublicKey must be an asymmetric key when using ${header.alg}`));\n    }\n\n    if (!options.allowInvalidAsymmetricKeyTypes) {\n      try {\n        validateAsymmetricKey(header.alg, secretOrPublicKey);\n      } catch (e) {\n        return done(e);\n      }\n    }\n\n    let valid;\n\n    try {\n      valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey);\n    } catch (e) {\n      return done(e);\n    }\n\n    if (!valid) {\n      return done(new JsonWebTokenError('invalid signature'));\n    }\n\n    const payload = decodedToken.payload;\n\n    if (typeof payload.nbf !== 'undefined' && !options.ignoreNotBefore) {\n      if (typeof payload.nbf !== 'number') {\n        return done(new JsonWebTokenError('invalid nbf value'));\n      }\n\n      if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {\n        return done(new NotBeforeError('jwt not active', new Date(payload.nbf * 1000)));\n      }\n    }\n\n    if (typeof payload.exp !== 'undefined' && !options.ignoreExpiration) {\n      if (typeof payload.exp !== 'number') {\n        return done(new JsonWebTokenError('invalid exp value'));\n      }\n\n      if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {\n        return done(new TokenExpiredError('jwt expired', new Date(payload.exp * 1000)));\n      }\n    }\n\n    if (options.audience) {\n      const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];\n      const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];\n      const match = target.some(function (targetAudience) {\n        return audiences.some(function (audience) {\n          return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;\n        });\n      });\n\n      if (!match) {\n        return done(new JsonWebTokenError('jwt audience invalid. expected: ' + audiences.join(' or ')));\n      }\n    }\n\n    if (options.issuer) {\n      const invalid_issuer = typeof options.issuer === 'string' && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;\n\n      if (invalid_issuer) {\n        return done(new JsonWebTokenError('jwt issuer invalid. expected: ' + options.issuer));\n      }\n    }\n\n    if (options.subject) {\n      if (payload.sub !== options.subject) {\n        return done(new JsonWebTokenError('jwt subject invalid. expected: ' + options.subject));\n      }\n    }\n\n    if (options.jwtid) {\n      if (payload.jti !== options.jwtid) {\n        return done(new JsonWebTokenError('jwt jwtid invalid. expected: ' + options.jwtid));\n      }\n    }\n\n    if (options.nonce) {\n      if (payload.nonce !== options.nonce) {\n        return done(new JsonWebTokenError('jwt nonce invalid. expected: ' + options.nonce));\n      }\n    }\n\n    if (options.maxAge) {\n      if (typeof payload.iat !== 'number') {\n        return done(new JsonWebTokenError('iat required when maxAge is specified'));\n      }\n\n      const maxAgeTimestamp = timespan(options.maxAge, payload.iat);\n\n      if (typeof maxAgeTimestamp === 'undefined') {\n        return done(new JsonWebTokenError('\"maxAge\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n      }\n\n      if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {\n        return done(new TokenExpiredError('maxAge exceeded', new Date(maxAgeTimestamp * 1000)));\n      }\n    }\n\n    if (options.complete === true) {\n      const signature = decodedToken.signature;\n      return done(null, {\n        header: header,\n        payload: payload,\n        signature: signature\n      });\n    }\n\n    return done(null, payload);\n  });\n};","map":{"version":3,"sources":["/Users/xiuhuiwang/Documents/USF/CS686_CloudComputing/final/mld/node_modules/jsonwebtoken/verify.js"],"names":["JsonWebTokenError","require","NotBeforeError","TokenExpiredError","decode","timespan","validateAsymmetricKey","PS_SUPPORTED","jws","KeyObject","createSecretKey","createPublicKey","PUB_KEY_ALGS","EC_KEY_ALGS","RSA_KEY_ALGS","HS_ALGS","splice","length","module","exports","jwtString","secretOrPublicKey","options","callback","Object","assign","done","err","data","clockTimestamp","nonce","undefined","trim","allowInvalidAsymmetricKeyTypes","Math","floor","Date","now","parts","split","decodedToken","complete","header","getSecret","secretCallback","message","hasSignature","algorithms","_","Buffer","from","type","includes","asymmetricKeyType","indexOf","alg","startsWith","test","e","valid","verify","payload","nbf","ignoreNotBefore","clockTolerance","exp","ignoreExpiration","audience","audiences","Array","isArray","target","aud","match","some","targetAudience","RegExp","join","issuer","invalid_issuer","iss","subject","sub","jwtid","jti","maxAge","iat","maxAgeTimestamp","signature"],"mappings":"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","sourcesContent":["const JsonWebTokenError = require('./lib/JsonWebTokenError');\nconst NotBeforeError = require('./lib/NotBeforeError');\nconst TokenExpiredError = require('./lib/TokenExpiredError');\nconst decode = require('./decode');\nconst timespan = require('./lib/timespan');\nconst validateAsymmetricKey = require('./lib/validateAsymmetricKey');\nconst PS_SUPPORTED = require('./lib/psSupported');\nconst jws = require('jws');\nconst {KeyObject, createSecretKey, createPublicKey} = require(\"crypto\");\n\nconst PUB_KEY_ALGS = ['RS256', 'RS384', 'RS512'];\nconst EC_KEY_ALGS = ['ES256', 'ES384', 'ES512'];\nconst RSA_KEY_ALGS = ['RS256', 'RS384', 'RS512'];\nconst HS_ALGS = ['HS256', 'HS384', 'HS512'];\n\nif (PS_SUPPORTED) {\n  PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, 'PS256', 'PS384', 'PS512');\n  RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, 'PS256', 'PS384', 'PS512');\n}\n\nmodule.exports = function (jwtString, secretOrPublicKey, options, callback) {\n  if ((typeof options === 'function') && !callback) {\n    callback = options;\n    options = {};\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  //clone this object since we are going to mutate it.\n  options = Object.assign({}, options);\n\n  let done;\n\n  if (callback) {\n    done = callback;\n  } else {\n    done = function(err, data) {\n      if (err) throw err;\n      return data;\n    };\n  }\n\n  if (options.clockTimestamp && typeof options.clockTimestamp !== 'number') {\n    return done(new JsonWebTokenError('clockTimestamp must be a number'));\n  }\n\n  if (options.nonce !== undefined && (typeof options.nonce !== 'string' || options.nonce.trim() === '')) {\n    return done(new JsonWebTokenError('nonce must be a non-empty string'));\n  }\n\n  if (options.allowInvalidAsymmetricKeyTypes !== undefined && typeof options.allowInvalidAsymmetricKeyTypes !== 'boolean') {\n    return done(new JsonWebTokenError('allowInvalidAsymmetricKeyTypes must be a boolean'));\n  }\n\n  const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);\n\n  if (!jwtString){\n    return done(new JsonWebTokenError('jwt must be provided'));\n  }\n\n  if (typeof jwtString !== 'string') {\n    return done(new JsonWebTokenError('jwt must be a string'));\n  }\n\n  const parts = jwtString.split('.');\n\n  if (parts.length !== 3){\n    return done(new JsonWebTokenError('jwt malformed'));\n  }\n\n  let decodedToken;\n\n  try {\n    decodedToken = decode(jwtString, { complete: true });\n  } catch(err) {\n    return done(err);\n  }\n\n  if (!decodedToken) {\n    return done(new JsonWebTokenError('invalid token'));\n  }\n\n  const header = decodedToken.header;\n  let getSecret;\n\n  if(typeof secretOrPublicKey === 'function') {\n    if(!callback) {\n      return done(new JsonWebTokenError('verify must be called asynchronous if secret or public key is provided as a callback'));\n    }\n\n    getSecret = secretOrPublicKey;\n  }\n  else {\n    getSecret = function(header, secretCallback) {\n      return secretCallback(null, secretOrPublicKey);\n    };\n  }\n\n  return getSecret(header, function(err, secretOrPublicKey) {\n    if(err) {\n      return done(new JsonWebTokenError('error in secret or public key callback: ' + err.message));\n    }\n\n    const hasSignature = parts[2].trim() !== '';\n\n    if (!hasSignature && secretOrPublicKey){\n      return done(new JsonWebTokenError('jwt signature is required'));\n    }\n\n    if (hasSignature && !secretOrPublicKey) {\n      return done(new JsonWebTokenError('secret or public key must be provided'));\n    }\n\n    if (!hasSignature && !options.algorithms) {\n      return done(new JsonWebTokenError('please specify \"none\" in \"algorithms\" to verify unsigned tokens'));\n    }\n\n    if (secretOrPublicKey != null && !(secretOrPublicKey instanceof KeyObject)) {\n      try {\n        secretOrPublicKey = createPublicKey(secretOrPublicKey);\n      } catch (_) {\n        try {\n          secretOrPublicKey = createSecretKey(typeof secretOrPublicKey === 'string' ? Buffer.from(secretOrPublicKey) : secretOrPublicKey);\n        } catch (_) {\n          return done(new JsonWebTokenError('secretOrPublicKey is not valid key material'))\n        }\n      }\n    }\n\n    if (!options.algorithms) {\n      if (secretOrPublicKey.type === 'secret') {\n        options.algorithms = HS_ALGS;\n      } else if (['rsa', 'rsa-pss'].includes(secretOrPublicKey.asymmetricKeyType)) {\n        options.algorithms = RSA_KEY_ALGS\n      } else if (secretOrPublicKey.asymmetricKeyType === 'ec') {\n        options.algorithms = EC_KEY_ALGS\n      } else {\n        options.algorithms = PUB_KEY_ALGS\n      }\n    }\n\n    if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {\n      return done(new JsonWebTokenError('invalid algorithm'));\n    }\n\n    if (header.alg.startsWith('HS') && secretOrPublicKey.type !== 'secret') {\n      return done(new JsonWebTokenError((`secretOrPublicKey must be a symmetric key when using ${header.alg}`)))\n    } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey.type !== 'public') {\n      return done(new JsonWebTokenError((`secretOrPublicKey must be an asymmetric key when using ${header.alg}`)))\n    }\n\n    if (!options.allowInvalidAsymmetricKeyTypes) {\n      try {\n        validateAsymmetricKey(header.alg, secretOrPublicKey);\n      } catch (e) {\n        return done(e);\n      }\n    }\n\n    let valid;\n\n    try {\n      valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey);\n    } catch (e) {\n      return done(e);\n    }\n\n    if (!valid) {\n      return done(new JsonWebTokenError('invalid signature'));\n    }\n\n    const payload = decodedToken.payload;\n\n    if (typeof payload.nbf !== 'undefined' && !options.ignoreNotBefore) {\n      if (typeof payload.nbf !== 'number') {\n        return done(new JsonWebTokenError('invalid nbf value'));\n      }\n      if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {\n        return done(new NotBeforeError('jwt not active', new Date(payload.nbf * 1000)));\n      }\n    }\n\n    if (typeof payload.exp !== 'undefined' && !options.ignoreExpiration) {\n      if (typeof payload.exp !== 'number') {\n        return done(new JsonWebTokenError('invalid exp value'));\n      }\n      if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {\n        return done(new TokenExpiredError('jwt expired', new Date(payload.exp * 1000)));\n      }\n    }\n\n    if (options.audience) {\n      const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];\n      const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];\n\n      const match = target.some(function (targetAudience) {\n        return audiences.some(function (audience) {\n          return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;\n        });\n      });\n\n      if (!match) {\n        return done(new JsonWebTokenError('jwt audience invalid. expected: ' + audiences.join(' or ')));\n      }\n    }\n\n    if (options.issuer) {\n      const invalid_issuer =\n              (typeof options.issuer === 'string' && payload.iss !== options.issuer) ||\n              (Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1);\n\n      if (invalid_issuer) {\n        return done(new JsonWebTokenError('jwt issuer invalid. expected: ' + options.issuer));\n      }\n    }\n\n    if (options.subject) {\n      if (payload.sub !== options.subject) {\n        return done(new JsonWebTokenError('jwt subject invalid. expected: ' + options.subject));\n      }\n    }\n\n    if (options.jwtid) {\n      if (payload.jti !== options.jwtid) {\n        return done(new JsonWebTokenError('jwt jwtid invalid. expected: ' + options.jwtid));\n      }\n    }\n\n    if (options.nonce) {\n      if (payload.nonce !== options.nonce) {\n        return done(new JsonWebTokenError('jwt nonce invalid. expected: ' + options.nonce));\n      }\n    }\n\n    if (options.maxAge) {\n      if (typeof payload.iat !== 'number') {\n        return done(new JsonWebTokenError('iat required when maxAge is specified'));\n      }\n\n      const maxAgeTimestamp = timespan(options.maxAge, payload.iat);\n      if (typeof maxAgeTimestamp === 'undefined') {\n        return done(new JsonWebTokenError('\"maxAge\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n      }\n      if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {\n        return done(new TokenExpiredError('maxAge exceeded', new Date(maxAgeTimestamp * 1000)));\n      }\n    }\n\n    if (options.complete === true) {\n      const signature = decodedToken.signature;\n\n      return done(null, {\n        header: header,\n        payload: payload,\n        signature: signature\n      });\n    }\n\n    return done(null, payload);\n  });\n};\n"]},"metadata":{},"sourceType":"script"}